# program structure
函数以源文件和包的方式被组织。
## 命名（names）
Go语言中的函数名、变量名、常量名、类型名、包名、语句标号等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。Go语言中变量名大小写敏感，例如heapSort和Heapsort是两个不同的名字。

Go的关键字比较少，只有25个，比26个字母还少一个。它们是
    流程控制： for switch break continue goto default fallthrough if else case 			 range
    复合类型： map chan func interface struct
    基础类型： int
    并发功能： go	select
    其他： import type var return	const defer

此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
    内建常量：true false iota nil
    内建类型： int int8 int16 int32 int64
                 uint uint8 uint16 uint32 uint64 uintptr
                 float32 float64 complex128 complex64
                 bool	byte rune string error

数据类型的作用：告诉编译器这个数（变量应该分配多大的内存。

    内建函数：make len cap new append copy close delete
            complex real imag
            panic recover
        
名字的首字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（**必须是在函数外部定义的包级别名字；包级别函数名也是包级别名字**），那么它是可导出的（exported），也就是说可以被外部的包访问，例如fmt包的Println函数就是可导出的。包本身的名字一般总是用小写字母。

Go语言的风格是尽量使用短小的名字，对于局部变量尤其如此。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。

在习惯上，GO语言程序员推荐使用驼峰式命名。你会在标准库中看到QuoteRuneToASCII和parseRequestLine这样的函数命名。但一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。而像ACSII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape，但不会是escapeHtml。

## 声明（declarations）

声明语句定义了程序的各种实体对象以及部分或全部的属性（常见于结构体）。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其他包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要。

package

import

type

struct

const

func

一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。执行函数从函数的第一个语句开始，依次顺序执行**直到遇到return返回语句**，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。

## 变量（variable）

变量：程序运行期间，可以改变的量。

### 变量声明
1、声明一组变量

    var i,j,k int   //int,int,int

2、用一组初始化表达式声明并初始化一组变量

    var b,f,s=true,2.3,"four"   //bool,float64,string

初始化表达式可以是字面量或任意的表达式。

3、一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化

    var f,err:=os.Open(name)

### 变量初始化
### 变量赋值
变量初始化（声明变量，同时赋值【一步到位】）

    var s int=10  //变量初始化

    s=100         //赋值（先声明，后赋值）

    package main
    import "fmt"
    func main(){
        a=100       //报错  这事赋值，赋值前，必须要声明变量
        fmt.Printf("a=%d",a)
    }

### 短变量声明（short variable declarations）

在函数内部，有一种称为短变量声明语句的形式可用于声明和初始化局部变量。
格式：变量名:=表达式

变量的类型根据表达式来自动推导。

短变量声明 vs var形式声明
1、短变量简洁、灵活的特点常被用于大部分的局部变量的声明和初始化。
2、var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

    var err error
    i:=100

3、两者都可用于声明和初始化一组变量

    i,j:=0,1

但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for循环的初始化语句部分。

注意：":="是一个变量声明语句，而"="是一个变量赋值操作。也不要混淆多个变量的声明和元组（tuple）的多重赋值，后者是将右边各个表达式
值赋给左边对应的各个变量：

    i,j=j,i   //交换i和j的值

传统的做法需要借助一个辅助变量。

4、短变量声明语句也可以用函数的返回值来声明和初始化变量。

    f,err:=os.File(name)
    if err!=nil{
        return err
    }
    //... use f ...
    f.Close()

这里有一个比较微妙的地方：短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域（一个{}内？）声明过了，那么短变量
声明语句对这些已经声明过的变量就只有赋值行为了。

    in,err:=os.Open(infile)     //声明了两个变量
    //...
    out,err:=os.Create(outfile)   //只声明了一个out变量，然后对已经声明的err进行了赋值操作

短变量声明语句中**至少**要声明**一个新的变量**。
    
    f,err:=os.File(infile)
    //...
    f,err:=os.File(outfile)    //compile error：no new variables

解决方法是第二个短变量声明语句改用普通的多重赋值语句。

短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么短变量声明语句将会在当前词法域
重新声明一个新的变量。例子见上面。

### 指针

一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达式
方式引入，例如x[i]或x.f变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋予一个新的值。

一个指针的值是一个变量的地址。指针对应变量在内存中的存储位置。并不是每一个值都会有内存地址，但是对于每一个变量必然有相应的内存地址（这句话如何理解？）。通过指针，
我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。

    var i int
    fmt.Printf("%p\n",&i)
    p:=&i
    fmt.Printf("%v\n",p)  //"<nil>"
    fmt.Printf("%T\n",p)  //"*int"
    *p=100                //等价于i=100
    fmt.Println(i)        //"100"

我们称"p指针指向变量x"，或者说"p指针保存了变量x的内存地址"。*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，同时因为*p
对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。

聚合类型的每个成员——比如结构体的每个字段或者数组的每个元素——也都是对应一个变量，因此也可以被取地址。

变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作。

任何类型的指针的零值都是nil）。如果p!=nil测试为真(p是上面的定义的指针变量)，那么p是指向某个有效值。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

    var x,y int
    fmt.Printf(&x==&x,&y=&x,&x==nil)    //"true false false"

Printf中第一个参数是指向同一个变量x相比，第二个参数是指向不同变量指针的比较，最后一个参数是和nil比较。
在Go语言中，返回函数中局部变量的地址也是安全的。请看代码：
    
    var p=f()
    
    func f() *int{
        v:=1
        return &v
    }
每次调用f函数都将返回不同的结果：

    fmt.Printf(f()==f())  //"false"

因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数通过该指针来更新变量的值。

    func incr(p *int) int{
        *p++          //只是增加p指向的变量的值，并不改变p指针
        return *p
    }
    
    v:=1
    incr(&1)                  //v is now 2
    fmt.Println(incr(&v))     //"3"

指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（这是
Go语言的垃圾回收器所做的工作）。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建
所引用变量的别名。

指针是实现标准库中flag包的关键技术，它使用命令行参数用来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。


### new函数

另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。

    p:=new(int)      //p,*int类型，指向匿名的int变量
    fmt.Println(*p)  //"0"
    *p=2             //设置int匿名变量的值为2
    fmt.Println(*p)  //2

用new创建变量和普通变量声明语句方式创建便来给你没什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数
类似是一种语法糖，而不是一个新的基础概念。

下面是两个newInt函数有着相同的行为：

    func newInt() *int{
        return new(int)
    }

    func newInt() *int{
        var dummy int
        return &dummy
    }

每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
    
    p:=new(int)
    q:=new(int)
    fmt.Println(p==q)  //"false"

当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int有可能有相同的地址（依赖具体的语言实现）
注意：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档。

new函数相对使用较少，因为对结构体来说，直接用字面量语法创建新变量的方法会更灵活。

### 变量的生命周期（lifetime of variables）

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。局部变量的生命周期
是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。
它们在函数每次被调用的时候创建。

编译器会自动选择在栈上还是堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。


## 赋值(assignments)

赋值可以更新一个变量的值。最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。
    
    x=1       //命名变量的赋值
    *p=true   //通过指针间接赋值
    person.name="bob"   //结构体字段赋值

熟知变量也可以支持++递增和--递减语句（**自增和自减是语句，而不是表达式，因此x=i++之类的表达式是错误的**）：
    
    v:=1
    v++
    v--

## 元组赋值(tuple assignment)

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会进行求值，然后再统一更新左边对应变量
的值。这对于处理有些同时出现在元组赋值语句两边的变量很有帮助。

    x,y=y,x
    a[i],a[j]=a[j],a[i]
    
    func gcd(x,y int) int{
        for y!=0{
            x,y=y,x%y
        }
        return x
    }
    
    func bi(n int) int{
        x,y:=o,1
        for i:=0;i<n;i++{
            x,y=y,x+y
        }
        return x
    }
    
元组赋值也可以使一系列琐碎赋值更加紧凑。
    
    i,j,k=2,3,5

但如果表达式太复杂的话，应该尽量避免过度使用元组赋值：因为每个变量单独赋值语句的写法可读性会更好。

有些表达式会产生多个值，比如调用一个有多个返回值的函数。
   
    v,ok=m[key]    //map查找
    v,ok=x.(T)     //类型断言
    v,ok=<-ch      //通道接收

我们可以用下划线_来丢弃不需要的值。
  
    _,err=io.Copy(dst,src)   //丢弃字节数
    _,ok=x.(T)               //只检测类型，忽略具体值

## 可赋值性(assignability)

赋值语句是显式的赋值形式，但是**程序中还有很多地方会发生隐式的赋值行为**。
    
    1、函数调用会隐式地将调用参数的值赋给函数的参数变量
    2、一个返回语句将隐式地将返回操作的值赋值给结果变量
    3、一个复合类型的字面量也会产生赋值行为。
    例如：medals:=[]string{"gold","silver","bronze"}
    
隐式地对slice的每个元素进行赋值操作，类似这样写的行为：
    
    medals[0]="gold"
    medals[1]="silver"
    medals[2]="bronze"
map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。

anyway，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

目前来说，可赋值性的规则很简单：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。

对于两个值是否可以用==或!=进行相等比较也和可赋值能力有关系：对于任何类型的值的相等比较，
第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然（第一个值必须对第二个值类型是可赋值的）。

## 类型(type declarations)

类型声明语句创建一个新的命名类型，和现有类型具有相同的底层结构。新命名的类型提供了一种方式分隔不同概念
的类型，这样即使它们底层类型相同也是不兼容的。
    
    type name underlying-type

类型声明一般出现在包一级。新创建的命令类型遵循可见性负责。

    package tempconv0
    
    import "fmt"
    
    type Celsius float64      //摄氏温度
    type Fahrenheit float64   //华氏温度
    
    const(
        AbsoluteZeroC   Celsius=-273.15   //绝对零度
        FreezingC       Celsius=0         //结冰点温度
        BoilingC        Celsius=100       //沸水温度
    )
    
    func CToF(c Celsius) Fahrenheit{ return Fahrenheit(c*9/5+32)}
    
    func FToC(c Fahrenheit) Celsius{ return Celsius((f-32)*5/9)}

类型转换不会改变值本身，但是会使它们的语义发生变化。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构
的指针类型，这些转换只改变类型而不会影响值本身。

命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。

类型声明还是经常用的。

## 包和文件(packages and files)
包的好处：支持模块化、封装、单独编译和代码复用。
通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释。
如果包注释很大，通常会放到一个独立的doc.go文件中（这一点在go-ethereum的代码里面比较常用）。

## 导入包

导入路径，类似github.com/ethereum/go-ethereum/p2p
按照惯例，包名和包的导入路径的最后一个字段相同。例如上面的包名是p2p。并不要求包名是唯一，只要导入路径全局是唯一就OK。

如果导入一个包，但是又没有使用该包将被当作一个编译错误处理。一个解决办法是使用golang.org/x/tools/cmd/goimports导入工具，
它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成imports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以
用来格式化Go源文件。

## 包的初始化
1、当前go源文件中，每个被import的包，按其在源文件中出现顺序初始化。

2、包A 引入包B，包B又引入包C，则包的初始化顺序为：C->B->A

3、main包总是最后一个被初始化

4、Go语言的构建工具会对.go文件根据字典序排序，然后依次调用编译器编译

5、当前包的包级变量（常量）根据在文件中出现的先后顺序依次初始化

可以进一步参考《Go语言程序设计》by Mark Summerfield中的5.6.2节。

掌握包的初始化还是蛮重要的。go-ethereum和tendermint的启动流程都是先运行init函数。最后才进入main函数的。

## 作用域

注意区分作用域和变量的生命周期，它们不是一回事。

语法块（todo）

全局语法块（todo）

词法域（todo）
    













	

